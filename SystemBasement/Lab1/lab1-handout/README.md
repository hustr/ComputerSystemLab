# 个人的答案解析

## 最低位置0

可以使用移位运算，先右移再左移。

```c
int lsbZero(int x) {
  return (x>>1)<<1;
}
```

## 对字节取非

可以使用异或的性质，bit级别异或的作用：

- 与0异或不变
- 与1异或取反

所以可以使用`0xFF`左移对应位数(`8n`)，取异或，而`8n`可以写为`n<<3`。

```c
int byteNot(int x, int n) {
  return x^(0xFF<<(n<<3));
}
```

## 对同位字节取异或

给定`x`、`y`、`n`，判断`x`和`y`的第`n`字节是否相同，相同返回`0`, 否则返回`1`。可以先取异或，再将第`n`字节取出进行判`0`。

```c
int byteXor(int x, int y, int n) {
  return !!((x^y)&(0xFF<<(n<<3)));
}
```

## 逻辑与

给定`x`、`y`，返回两者的逻辑与结果，直接判`0`取与。

```c
int logicalAnd(int x, int y) {
  return (!!x)&(!!y);
}
```

## 逻辑或

同上，最后取或。

```c
int logicalOr(int x, int y) {
  return (!!x)|(!!y);
}
```

## 循环左移

题目中的循环左移是以`bit`为单位，可将参数左移`n`，取得高位，再右移`32 - n`位，将右移结果取低`n`位，或高位。

```c
int rotateLeft(int x, int n) {
  return (x<<n)|((x>>(32+ ~n + 1))&~(~0<<n));
}
```

## 检查bit 1奇偶

给定参数`x`，返回二进制中`1`的个数是奇数还是偶数，这个问题我想到了`数字逻辑`中的一位二进制加法器，两个二进制数的与是进位，异或是本位和，现在需要判断的就是1个数最低位，考虑使用异或，高2字节异或低两字节想当于高低位的1个数求和的本位和，进位不需要考虑，依次递推得到最低位奇偶。

```c
int parityCheck(int x) {
  x ^= x >> 16;
  x ^= x >> 8;
  x ^= x >> 4;
  x ^= x >> 2;
  x ^= x >> 1;
  return x & 1;
}
```

## 检查乘2溢出

乘以2相当于左移1位，这个溢出的表现就是符号改变，符号不变时没有溢出，因此检测最高为和次高位是否相同。

```c
int mul2OK(int x) {
  return (x>>31)^(x>>30)^1;;
}
```

## 计算乘3除2

乘法部分使用移位再加即可，除法部分使用移位，向右移1位，不过需要注意的是负数需要先加上$2^n - 1$，`n`为移位数，此题目中`n`为1。

```c
int mult3div2(int x) {
  x += x << 1;
  x += (x>>31)&1;
  return x >> 1;
}
```

## 检查减法是否溢出

首先要明白减法在符号相同时是不会溢出的，只有符号不同时才会溢出，符号不同时可知结果的符号肯定与被减数符号相同，不同即发生溢出。

```c
int subOK(int x, int y) {
    return !(((x>>31)^(y>>31))&((x>>31)^((x + ~y + 1)>>31)));
}
```

## 获取绝对值

将`x`与符号为取异或加上符号位就是绝对值。

```c
int absVal(int x) {
    return (x^(x>>31)) + ((x>>31)&1);
}
```

## 浮点数绝对值

首先判断是否是`NaN`，是的话返回参数，否则符号为置0返回。

```c
unsigned float_abs(unsigned uf) {
    if (!((uf^0x7FC00000)&(uf^0xFFC00000))) {
        return uf;
    }
    return uf & 0x7FFFFFFF;
}
```

## 浮点数转整数

首先判断是否是`NaN`，再获取符号位，小数位，指数位，小数位取出来时是已经左移了23位的，指数位不要忘记`bias`。

```c
int float_f2i(unsigned uf) {
    if (!((uf^0x7fc00000)&&(uf^0xffc00000))) {
        return 0x80000000;
    }
    int s = (uf>>31)&1;
    int m = (uf&0x7FFFFF)|(1<<23);
    int e = ((uf>>23)&0xFF)- 127;
    if (e < 0) {
        return 0;
    } else if(e > 31) {
        return 0x80000000;
    }else if (e < 23) {
        m >>= 23 - e;
    } else {
        m <<= e - 23;
    }
    return s ? -m : m;
}
```

