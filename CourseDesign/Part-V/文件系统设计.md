# 带多级目录文件系统设计

## 目标

设计文件系统，具有文件的创建删除读写、~~目录创建删除~~功能。

## 设计

文件系统的设计，由于不打算加入账户控制功能，便于实现，降低难度，查阅资料打算参考FAT文件系统进行设计，磁盘上的内容需要进行分区，并对空闲块和已用块使用链式结构进行操作。

具体的代码中需要对系统进行分层设计，降低代码的耦合程度。

### 最底层

最底层直接操作磁盘块，这里需要对磁盘块进行定义，一般情况下磁盘块的大小是512个字节，此处也就直接沿用。此处需要向上提供读写磁盘块的api，具体可以看做每次读写必须以一个磁盘块为单位。显然如果想要正确的将文件指针定位到正确的位置的话是需要将文件系统的头部~~和目录~~所占用的大小加上的，这个确实需要考虑。

```c++
#define BLK_SIZE 512
struct block_t {
   	unsigned char data[BLK_SIZE];
};
// 输入磁盘块的id，将磁盘块的内容写入blk中并返回true，读取失败返回false
bool read_blk(int32_t id, block_t &blk);
// 将blk的内容写入到对应的磁盘块，返回写入结果
bool write_blk(int32_t id, const blkck_t &blk);
```

### 文件层

定义文件~~和目录~~和一些数据结构，具体的类型定义。提供目录的读写，文件的读写。

FAT表定义，这里存放每个文件的磁盘块的分布，给定一个起始块号的话应该可以通过这个起始块号得到这个文件所有的磁盘块号，实际的定义也就是一个一维数组，实际数目与磁盘块数目有关，同时需要保存空闲块的起始与结束块号。

```c++
// 所有的磁盘块数目，一个文件的前4个字节存储
int32_t blk_cnt;
struct free_blk_t {
  	int32_t start; // 空闲块链起点块号，便于取出操作
    int32_t end; // 最后一块空闲块的块号，便于添加操作
    int32_t root; // 文件起始磁盘块号
    int32_t *blks; // = new int[blk_cnt];
};
```

空闲的FAT链表，已使用了的FAT链表。

```c++
// 对FAT表进行操作
// 将一个磁盘块放入空闲块链末端，为便于实现将不对参数进行检查
bool add_to_unused(const int32_t &id);
// 获取一个未使用的磁盘块，取的是空闲块链头部的块，并将其从移出空闲块链
bool get_unused(int32_t &id);
```

文件定义，先实现单级目录吧

```c++
struct file_t {
  	char name[64]; // 文件名
    int32_t size; // 文件字节数
    int32_t start_blk; // 起始块号
};
file_t files[128]; // 将其写入到磁盘开始处
```





目录和文件的话最好定义成一个东西，只在

首先定义目录，目录这个东西，路径需要吗？树型的目录应该如何实现？如果要实现目录的话是将目录写到哪个区。

文件定义，包含文件名（是否可以选择直接存放到目录一级下面？），路径？，起始磁盘块号，文件大小（字节数）。

### 操作层

使用文件层的api，对输入的命令进行解析，并转化为实际的文件操作。